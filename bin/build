#!/usr/bin/env node

var archiver = require('archiver');
var exec = require('child_process').exec;
var fs = require('fs-extra');
var os = require('os');
var path = require('path');

var shell = require('../app/utils/shell.js');

var packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json')));
packageJson.window.toolbar = false;
if (process.argv[2]) {
  packageJson.version = process.argv[2];
}

var pngIconPath = path.join.apply(path, [ __dirname, '..' ].concat(packageJson.window.icon.split('/')));
var icoIconPath = pngIconPath.replace(/\.png$/, '.ico');
var icnsIconPath = pngIconPath.replace(/\.png$/, '.icns');

function buildDir(subdir) {
  var buildDir = path.join(__dirname, '..', 'build', subdir || '');
  if (!fs.existsSync(buildDir)) {
    fs.mkdirSync(buildDir);
  }
  return buildDir;
}

function prodDependencies() {
  var deps = Object.keys(packageJson.dependencies);
  return deps.map(function(dep) {
    return path.join('node_modules', dep);
  });
}

var appManifest = [
  'app/',
  'config/',
  'index.html',
  'node-main.js',
  'static/',
].concat(prodDependencies());

if (os.platform() === 'win32') {
  appManifest.push('bin/IconExtractor.exe');
}

fs.deleteSync(path.join(__dirname, '..', 'build'));
fs.mkdirSync(path.join(__dirname, '..', 'build'));

var appZip = archiver('zip');
var archiveName = packageJson.name + '.nw';
var appZipOutputPath = path.join(buildDir(), archiveName);
var output = fs.createWriteStream(appZipOutputPath);
appZip.pipe(output);

console.log('package.json');
appZip.append(JSON.stringify(packageJson), { name: 'package.json', store: true });

while (appManifest.length > 0) {
  var fileToInclude = appManifest.shift();
  var fullPath = path.join(__dirname, '..', fileToInclude);
  if (fs.statSync(fullPath).isDirectory()) {
    fs.readdirSync(fullPath).forEach(function(file) {
      appManifest.push(path.join(fileToInclude, file));
    });
  } else {
    var normalizedFilename = fileToInclude.replace(/\\/g, '/');
    console.log(normalizedFilename);
    appZip.append(fs.readFileSync(fullPath), { name: normalizedFilename, store: true });
  }
}

function changePlistString(plist, key, newValue) {
  var searchRegex = new RegExp('(<key>' + key + '<\\/key>\\s*<string>)[^<]*(<\\/string>)');
  return plist.replace(searchRegex, '$1' + newValue + '$2');
}

appZip.finalize(function(err, bytesWritten) {
  if (err) {
    throw err;
  }

  console.log(bytesWritten + ' total bytes written to ' + appZipOutputPath);

  if (os.platform() === 'win32') {
    fs.copy(path.join(__dirname, '..', 'nw', 'node-webkit-v0.5.1-win-ia32'), buildDir('windows'), function(err) {
      if (err) {
        throw err;
      }
      fs.unlinkSync(path.join(buildDir('windows'), 'nwsnapshot.exe'));
      var exePath = path.join(buildDir('windows'), 'nw.exe');
      var clearIconCommand = shell.escape(path.join(__dirname, 'RCEDIT.exe')) + ' /C ' + shell.escape(exePath);
      var setIconCommand = shell.escape(path.join(__dirname, 'RCEDIT.exe')) + ' /I ' + shell.escape(exePath) + ' ' + shell.escape(icoIconPath);

      console.log(clearIconCommand);
       exec(clearIconCommand, function(err, stdout, stderr) {
        if (err) {
          console.log('stdout: ' + stdout);
          console.log('stderr: ' + stderr);
          throw err;
        }

        console.log(setIconCommand);
        exec(setIconCommand, function(err, stdout, stderr) {
          if (err) {
            console.log('stdout: ' + stdout);
            console.log('stderr: ' + stderr);
            throw err;
          }

          var executable = fs.readFileSync(exePath);
          var nwArchive = fs.readFileSync(path.join(buildDir(), archiveName));
          fs.writeFileSync(path.join(buildDir('windows'), packageJson.name + '.exe'), Buffer.concat([ executable, nwArchive ]));
          fs.unlinkSync(path.join(buildDir('windows'), 'nw.exe'));

          console.log('Wrote Windows version ' + packageJson.version + ' to: ' + buildDir('windows'));
        });
      });
    });
  } else {
    console.log('Building for Windows must be done on Windows, unfortunately.');
  }

  fs.copy(path.join(__dirname, '..', 'nw', 'node-webkit-v0.5.1-osx-ia32', 'node-webkit.app'), path.join(buildDir('osx'), packageJson.name + '.app'), function(err) {
    if (err) {
      throw err;
    }

    fs.copy(appZipOutputPath, path.join(buildDir('osx'), packageJson.name + '.app', 'Contents', 'Resources', 'app.nw'), function(err) {
      if (err) {
        throw err;
      }

      var icon = fs.readFileSync(icnsIconPath);
      fs.writeFileSync(path.join(buildDir('osx'), packageJson.name + '.app', 'Contents', 'Resources', packageJson.name + '.icns'), icon);
      fs.unlinkSync(path.join(buildDir('osx'), packageJson.name + '.app', 'Contents', 'Resources', 'nw.icns'));

      var infoPlistPath = path.join(buildDir('osx'), packageJson.name + '.app', 'Contents', 'Info.plist');
      var plist = fs.readFileSync(infoPlistPath, 'utf-8');
      plist = changePlistString(plist, 'CFBundleDisplayName', packageJson.name);
      plist = changePlistString(plist, 'CFBundleName', packageJson.name);
      plist = changePlistString(plist, 'CFBundleVersion', packageJson.version);
      plist = changePlistString(plist, 'CFBundleShortVersionString', packageJson.version);
      plist = changePlistString(plist, 'CFBundleIconFile', packageJson.name + '.icns');
      fs.writeFileSync(infoPlistPath, plist);

      console.log('Wrote OS X version ' + packageJson.version + ' to: ' + buildDir('osx'));
    });
  });
});

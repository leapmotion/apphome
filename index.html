<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" type="text/css" href="./static/css/reset.css"/>
  <link rel="stylesheet" type="text/css" href="./static/css/fonts.css"/>
  <link rel="stylesheet" type="text/css" href="./static/css/shared.css"/>
  <script src="./static/js/raven-1.0.8.min.js"></script>
  <script>
    Raven.config('https://03b4e3bdfc974421860ef1a2747540b6:97e879a1dd80479f86c9780a415b0f80@app.getsentry.com/9610').install();
  </script>
  <script type="text/javascript">
    (function(c,a){window.mixpanel=a;var b,d,h,e;b=c.createElement("script");
    b.type="text/javascript";b.async=!0;b.src=("https:"===c.location.protocol?"https:":"http:")+
    '//cdn.mxpnl.com/libs/mixpanel-2.2.min.js';d=c.getElementsByTagName("script")[0];
    d.parentNode.insertBefore(b,d);a._i=[];a.init=function(b,c,f){function d(a,b){
    var c=b.split(".");2==c.length&&(a=a[c[0]],b=c[1]);a[b]=function(){a.push([b].concat(
    Array.prototype.slice.call(arguments,0)))}}var g=a;"undefined"!==typeof f?g=a[f]=[]:
    f="mixpanel";g.people=g.people||[];h=['disable','track','track_pageview','track_links',
    'track_forms','register','register_once','unregister','identify','alias','name_tag','set_config',
    'people.set','people.set_once','people.increment','people.track_charge','people.append'];
    for(e=0;e<h.length;e++)d(g,h[e]);a._i.push([b,c,f])};a.__SV=1.2;})(document,window.mixpanel||[]);
    mixpanel.init("77d363605f0470115eb82352f14b2981");
</script>
  <script src="./static/js/jquery-2.0.0.js"></script>
  <script src="./static/js/jquery-ui-1.10.3.js"></script>
  <script src="./node_modules/underscore/underscore.js"></script>
  <script src="./node_modules/backbone/backbone.js"></script>
  <script src="./static/js/Tween.js"></script>
  <script src="./static/notifications/nw-desktop-notifications.js"></script>
  <!--<script src="./static/js/leap.min.js"></script>-->
</head>
<body class="startup">


  <script>
    (function() {
      process.env.LEAPHOME_ENV = process.env.LEAPHOME_ENV || 'production';
      var path = require('path');
      global.$ = window.$;
      global._ = window._;
      global.LeapHomeDir = path.resolve('.');
      global.nwGui = window.nwGui = require('nw.gui');
      global.document = window.document;
      var uiGlobals = global.uiGlobals = require('./app/ui-globals.js');
      window.document.title = global.uiGlobals.appName;
      require('./app/utils/logging.js');

      var bootstrapScriptPath = process.env.BOOTSTRAP_SCRIPT_PATH || './app/airspace.js'; // a hook primarily used for testing
      var airspace = require(bootstrapScriptPath);
      console.log('Starting ' + uiGlobals.appName + ' v' + uiGlobals.appVersion + ' on node-webkit v' + process.versions['node-webkit']);

      window.onload = function() {
        airspace.run();
      };

      var serialize = function(obj) {
        var str = [];
        for(var p in obj)
           str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        return str.join("&");
      }

      global.postData = function(url, data, cb) {
        var params = serialize(data);
        // console.log('postData', url, params, data);
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url, true);
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhr.onload = function () {
          // console.log('posted to', url, this.responseText);
          cb && cb(null, this.responseText);
        };
        xhr.send(params);
      }

      global.getData = function(url, cb) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onload = function () {
          // console.log('getData', url, this.responseText);
          cb && cb(null, this.responseText);
        };
        xhr.send(null);
      }

      global.downloadFile = function(url, chunkcb, cb, chunksize, progresscb) {
        var totalsize = 0;
        var cumulativedownload = 0;
        var progress = 0;
        var startoffset = 0;
        var xhr;

        var getFileSize = function(url, sizecb) {
          var http = new XMLHttpRequest();
          http.open('GET', url);
          http.onprogress = function(sizeEvent) {
            // console.log('size event', sizeEvent.total);
            this.abort();
            sizecb(sizeEvent.total);
          }
          http.send();
        }

        getFileSize(url, function(size) {
          // console.log('Got a size', size);
          if (size) {
            totalsize = size;
          }
        })

        var updateProgress = function(oEvent) {
          if (oEvent.lengthComputable) {
            if (! totalsize) return;
            progress = (cumulativedownload + oEvent.loaded) / totalsize;
            // console.log('updateProgress', progress, totalsize);
            progresscb && progresscb(progress);
          }
        }

        var transferFailed = function(error) {
          if (xhr.canceled) return;
          cb && cb(error);
        }

        var _arrayBufferToBase64 = function ( buffer ) {
          var binary = ''
          var bytes = new Uint8Array( buffer )
          var len = bytes.byteLength;
          for (var i = 0; i < len; i++) {
              binary += String.fromCharCode( bytes[ i ] )
          }
          return window.btoa( binary );
        }


        var downloadChunk = function(start, end, downloadcb) {
          // console.log('Downloading chunk', start, end);
          xhr = new XMLHttpRequest();
          var transferComplete = function() {
            var data = _arrayBufferToBase64(xhr.response);
            // console.log('transfercomplete', url, data.length);
            downloadcb && downloadcb(data);
          }

          xhr.addEventListener("onreadystatechange", transferFailed, false);
          xhr.addEventListener("progress", updateProgress, false);
          xhr.addEventListener("load", transferComplete, false);
          xhr.addEventListener("error", transferFailed, false);
          xhr.addEventListener("abort", transferFailed, false);

          xhr.open('GET', url, true);
          xhr.responseType = "arraybuffer";
          // console.log('downloading', url, start, end);
          xhr.setRequestHeader('range', 'bytes=' + start + '-' + end);
          xhr.send();
        }

        var checkProgress = function(data) {
          if (progress === 1) {
            // console.log('done downloading', data.length, url);
            chunkcb && chunkcb(null, data);
            cb && cb(null, data);
          } else {
            // console.log('downloaded chunk for startoffset', startoffset, data.length, chunksize);
            chunkcb && chunkcb(null, data);
            startoffset += chunksize;
            cumulativedownload += chunksize;
            downloadChunk(startoffset, startoffset + chunksize - 1, checkProgress);
          }
        }

        downloadChunk(startoffset, startoffset + chunksize - 1, checkProgress);

        var abortDownload = function() {
          if (xhr) {
            xhr.canceled = true;
            xhr.abort();
          }
        }
        return abortDownload;
      }
    })();
  </script>

    <script>

//    (function() {
//      var ctl = new Leap.Controller({enableGestures: true});
//      var swiper = ctl.gesture('swipe');
//
//      swiper.start(function(g) {
//        swiper.currentSwipe = g;
//      });
//
//      swiper.update(function(g) {
//        if (swiper.currentSwipe === true) return;
//        var pos = g.translation()[0];
//        if (Math.abs(pos) > 100) {
//          var isLeft = pos > 0;
//          global.uiGlobals.trigger('swipe' + (isLeft ? 'left' : 'right'));
//        }
//      });
//
//      // ctl.connect() FIXME re-enable experimentally somehow
//    })();
  </script>
</body>
</html>




// Generated by CoffeeScript 1.6.3
(function() {
  var FsScanner, async, crypto, exec, fs, os, path, plist, registry, semver, shell;

  async = require("async");

  crypto = require("crypto");

  exec = require("child_process").exec;

  fs = require("fs");

  os = require("os");

  path = require("path");

  plist = require("./plist.js");

  registry = require("./registry.js");

  semver = require("./semver.js");

  shell = require("./shell.js");

  FsScanner = function(allowedApps) {
    var _this = this;
    if (Array.isArray(allowedApps)) {
      this._allowedApps = {};
      return allowedApps.forEach(function(allowedApp) {
        if (allowedApp.findByScanning) {
          return _this._allowedApps[allowedApp.name.toLowerCase()] = allowedApp;
        }
      });
    }
  };

  FsScanner.prototype = {
    scan: function(cb) {
      var cleanData, err, platform;
      platform = os.platform();
      cleanData = function(err, apps) {
        if (err) {
          cb && cb(err);
        }
        apps = _.uniq(_(apps).compact(), function(app) {
          return app.get("id");
        });
        return cb && cb(null, apps);
      };
      try {
        if (platform === "win32") {
          return this._scanForWindowsApps(cleanData);
        } else if (platform === "darwin") {
          return this._scanForMacApps(cleanData);
        } else {
          return cb && cb(new Error("Unknown system platform: " + platform));
        }
      } catch (_error) {
        err = _error;
        return cb && cb(err);
      }
    },
    _scanForMacApps: function(cb) {
      var userAppsDir,
        _this = this;
      userAppsDir = path.join(process.env.HOME || "", "Applications");
      if (!fs.existsSync(userAppsDir)) {
        fs.mkdirSync(userAppsDir);
      }
      return exec("find ~/Applications /Applications -maxdepth 4 -name Info.plist", function(err, stdout) {
        var plistPaths;
        if (err) {
          return cb && cb(err);
        }
        plistPaths = stdout.toString().split("\n");
        plistPaths.pop();
        return async.mapLimit(plistPaths, 1, _this._createLeapAppFromPlistPath.bind(_this), function(err, leapApps) {
          if (err) {
            return cb(err);
          }
          return cb && cb(null, leapApps);
        });
      });
    },
    _createLeapAppFromPlistPath: function(plistPath, cb) {
      var _this = this;
      return plist.parseFile(plistPath, function(err, parsedPlist) {
        var attributes, icon, keyFile;
        if (err) {
          return cb(err);
        }
        keyFile = path.dirname(path.dirname(plistPath));
        attributes = {
          name: parsedPlist.CFBundleDisplayName || parsedPlist.CFBundleName || parsedPlist.CFBundleExecutable,
          version: parsedPlist.CFBundleShortVersionString || parsedPlist.CFBundleVersion,
          keyFile: keyFile
        };
        icon = parsedPlist.CFBundleIcon || parsedPlist.CFBundleIconFile;
        if (icon) {
          if (!path.extname(icon)) {
            icon = icon + ".icns";
          }
          attributes.rawIconFile = path.join(keyFile, "Contents", "Resources", icon);
        }
        return cb && cb(null, _this._createLocalLeapApp(attributes));
      });
    },
    _scanForWindowsApps: function(cb) {
      var registryQueries,
        _this = this;
      registryQueries = [
        function(cb) {
          return registry.readFullKey("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", cb);
        }, function(cb) {
          return registry.readFullKey("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", cb);
        }
      ];
      if (process.env.ProgramW6432) {
        registryQueries.push(function(cb) {
          return registry.readFullKey("HKLM\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall", cb);
        });
      }
      return async.parallel(registryQueries, function(err, stdouts) {
        var registryChunks;
        if (err) {
          return cb(err);
        }
        registryChunks = _.invoke(stdouts, "toString").join("\n").split(/^HKEY_LOCAL_MACHINE|^HKEY_CURRENT_USER/m);
        registryChunks.shift();
        return async.map(registryChunks, _this._createLeapAppFromRegistryChunk.bind(_this), function(err, leapApps) {
          if (err) {
            return cb && cb(err);
          }
          return cb && cb(null, leapApps);
        });
      });
    },
    _createLeapAppFromRegistryChunk: function(registryChunk, cb) {
      var allowedApp, attributes, extractValueForKey;
      extractValueForKey = function(key, type) {
        var firstGroup, match, regex;
        type = type || "REG_SZ";
        regex = new RegExp(key + " +" + type + " +([^\\n]+)");
        match = registryChunk.match(regex);
        firstGroup = (match && match[1]) || "";
        return firstGroup.replace(/^\s+|\s+$/g, "");
      };
      attributes = {
        name: extractValueForKey("DisplayName"),
        version: extractValueForKey("DisplayVersion"),
        keyFile: extractValueForKey("InstallLocation")
      };
      allowedApp = this._getAllowedApp(attributes.name);
      if (allowedApp && allowedApp.relativeExePath) {
        attributes.relativeExePath = allowedApp.relativeExePath;
        attributes.rawIconFile = path.join(attributes.keyFile, attributes.relativeExePath);
      }
      return cb && cb(null, this._createLocalLeapApp(attributes));
    },
    _createLocalLeapApp: function(attributes) {
      var LocalLeapApp, localLeapApp;
      if (!attributes.keyFile || !attributes.name || !attributes.version || !this._isAllowedApp(attributes.name, attributes.version)) {
        return null;
      }
      if (attributes.deletable !== false) {
        attributes.deletable = true;
      }
      attributes.findByScanning = true;
      LocalLeapApp = require("../models/local-leap-app.js");
      localLeapApp = new LocalLeapApp(attributes);
      if (localLeapApp.isValid()) {
        return localLeapApp;
      } else {
        return null;
      }
    },
    _getAllowedApp: function(appName) {
      return this._allowedApps && this._allowedApps[appName.toLowerCase()];
    },
    _isAllowedApp: function(appName, appVersion) {
      var allowedApp;
      if (!appName) {
        return false;
      } else if (!this._allowedApps) {
        return true;
      } else {
        allowedApp = this._getAllowedApp(appName);
        if (allowedApp) {
          if (allowedApp.minVersion) {
            return semver.isFirstGreaterThanSecond(appVersion, allowedApp.minVersion) || semver.areEqual(appVersion, allowedApp.minVersion);
          } else {
            return true;
          }
        } else {
          return false;
        }
      }
    }
  };

  module.exports = FsScanner;

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var FsScanner, async, crypto, exec, fs, os, path, plist, registry, semver, shell;

  async = require("async");

  crypto = require("crypto");

  exec = require("child_process").exec;

  fs = require("fs");

  os = require("os");

  path = require("path");

  plist = require("./plist.js");

  registry = require("./registry.js");

  semver = require("./semver.js");

  shell = require("./shell.js");

  FsScanner = function(allowedApps) {
    var _this = this;
    if (Array.isArray(allowedApps)) {
      this._allowedApps = {};
      return allowedApps.forEach(function(allowedApp) {
        if (allowedApp.findByScanning) {
          return _this._allowedApps[allowedApp.name.toLowerCase()] = allowedApp;
        }
      });
    }
  };

  FsScanner.prototype = {
    scan: function(cb) {
      var cleanData, err, platform;
      platform = os.platform();
      cleanData = function(err, appJsonList) {
        var appJson, _i, _len;
        if (err) {
          if (typeof cb === "function") {
            cb(err);
          }
        }
        appJsonList = _.uniq(_(appJsonList).compact());
        for (_i = 0, _len = appJsonList.length; _i < _len; _i++) {
          appJson = appJsonList[_i];
          appJson.cleaned = true;
        }
        return typeof cb === "function" ? cb(null, appJsonList) : void 0;
      };
      try {
        if (platform === "win32") {
          return this._scanForWindowsApps(cleanData);
        } else if (platform === "darwin") {
          return this._scanForMacApps(cleanData);
        } else {
          return typeof cb === "function" ? cb(new Error("Unknown system platform: " + platform)) : void 0;
        }
      } catch (_error) {
        err = _error;
        return typeof cb === "function" ? cb(err) : void 0;
      }
    },
    _scanForMacApps: function(cb) {
      var userAppsDir,
        _this = this;
      userAppsDir = path.join(process.env.HOME || "", "Applications");
      if (!fs.existsSync(userAppsDir)) {
        fs.mkdirSync(userAppsDir);
      }
      return exec("find ~/Applications /Applications -maxdepth 4 -name Info.plist", function(err, stdout) {
        var plistPaths;
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
        plistPaths = stdout.toString().split("\n");
        plistPaths.pop();
        return async.mapLimit(plistPaths, 1, _this._createAppJsonFromPlistPath.bind(_this), function(err, appJsonList) {
          if (err) {
            return cb(err);
          }
          return typeof cb === "function" ? cb(null, appJsonList) : void 0;
        });
      });
    },
    _createAppJsonFromPlistPath: function(plistPath, cb) {
      var _this = this;
      return plist.parseFile(plistPath, function(err, parsedPlist) {
        var attributes, icon, keyFile;
        if (err) {
          return cb(err);
        }
        keyFile = path.dirname(path.dirname(plistPath));
        attributes = {
          name: parsedPlist.CFBundleDisplayName || parsedPlist.CFBundleName || parsedPlist.CFBundleExecutable,
          version: parsedPlist.CFBundleShortVersionString || parsedPlist.CFBundleVersion,
          keyFile: keyFile
        };
        icon = parsedPlist.CFBundleIcon || parsedPlist.CFBundleIconFile;
        if (icon) {
          if (!path.extname(icon)) {
            icon = icon + ".icns";
          }
          attributes.rawIconFile = path.join(keyFile, "Contents", "Resources", icon);
        }
        return typeof cb === "function" ? cb(null, _this._createAppJson(attributes)) : void 0;
      });
    },
    _scanForWindowsApps: function(cb) {
      var registryQueries,
        _this = this;
      registryQueries = [
        function(cb) {
          return registry.readFullKey("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", cb);
        }, function(cb) {
          return registry.readFullKey("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", cb);
        }
      ];
      if (process.env.ProgramW6432) {
        registryQueries.push(function(cb) {
          return registry.readFullKey("HKLM\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall", cb);
        });
      }
      return async.parallel(registryQueries, function(err, stdouts) {
        var registryChunks;
        if (err) {
          return cb(err);
        }
        registryChunks = _.invoke(stdouts, "toString").join("\n").split(/^HKEY_LOCAL_MACHINE|^HKEY_CURRENT_USER/m);
        registryChunks.shift();
        return async.map(registryChunks, _this._createAppJsonFromRegistryChunk.bind(_this), function(err, appJsonList) {
          if (err) {
            return typeof cb === "function" ? cb(err) : void 0;
          }
          return typeof cb === "function" ? cb(null, appJsonList) : void 0;
        });
      });
    },
    _createAppJsonFromRegistryChunk: function(registryChunk, cb) {
      var allowedApp, attributes, extractValueForKey;
      extractValueForKey = function(key, type) {
        var firstGroup, match, regex;
        type = type || "REG_SZ";
        regex = new RegExp(key + " +" + type + " +([^\\n]+)");
        match = registryChunk.match(regex);
        firstGroup = (match && match[1]) || "";
        return firstGroup.replace(/^\s+|\s+$/g, "");
      };
      attributes = {
        name: extractValueForKey("DisplayName"),
        version: extractValueForKey("DisplayVersion"),
        keyFile: extractValueForKey("InstallLocation")
      };
      allowedApp = this._getAllowedApp(attributes.name);
      if (allowedApp && allowedApp.relativeExePath) {
        attributes.relativeExePath = allowedApp.relativeExePath;
        attributes.rawIconFile = path.join(attributes.keyFile, attributes.relativeExePath);
      }
      return typeof cb === "function" ? cb(null, this._createAppJson(attributes)) : void 0;
    },
    _createAppJson: function(attributes) {
      if (!attributes.keyFile || !attributes.name || !attributes.version || !this._isAllowedApp(attributes.name, attributes.version)) {
        return null;
      }
      if (attributes.deletable !== false) {
        attributes.deletable = true;
      }
      attributes.findByScanning = true;
      return attributes;
    },
    _getAllowedApp: function(appName) {
      return this._allowedApps && this._allowedApps[appName.toLowerCase()];
    },
    _isAllowedApp: function(appName, appVersion) {
      var allowedApp;
      if (!appName) {
        return false;
      } else if (!this._allowedApps) {
        return true;
      } else {
        allowedApp = this._getAllowedApp(appName);
        if (allowedApp) {
          if (allowedApp.minVersion) {
            return semver.isFirstGreaterThanSecond(appVersion, allowedApp.minVersion) || semver.areEqual(appVersion, allowedApp.minVersion);
          } else {
            return true;
          }
        } else {
          return false;
        }
      }
    }
  };

  module.exports = FsScanner;

}).call(this);

/*
//@ sourceMappingURL=fs-scanner.map
*/

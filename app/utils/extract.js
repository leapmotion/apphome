// Generated by CoffeeScript 1.7.1
(function() {
  var IgnoredWindowsFileRegex, MaxChildProcessBufferSize, Q, async, chmodRecursiveSync, exec, extractApp, fs, mv, os, path, plist, shell, unzipFile, _extractAppDmg, _extractAppZip, _unzipViaShell;

  async = require("async");

  exec = require("child_process").exec;

  fs = require("fs-extra");

  os = require("os");

  mv = require("mv");

  path = require("path");

  plist = require("plist");

  shell = require("./shell.js");

  Q = require("q");

  IgnoredWindowsFileRegex = /^\.|^__macosx$/i;

  MaxChildProcessBufferSize = 1024 * 1024 * 5;

  _unzipViaShell = function(src, dest, cb) {
    var command;
    command = void 0;
    if (os.platform() === "win32") {
      command = shell.escape(path.join(__dirname, "..", "..", "bin", "unzip.exe")) + " -o " + shell.escape(src) + " -d " + shell.escape(dest);
    } else {
      command = "unzip -o " + shell.escape(src) + " -d " + shell.escape(dest);
    }
    console.log("Unzipping with command: " + command);
    return exec(command, {
      maxBuffer: MaxChildProcessBufferSize
    }, cb);
  };

  unzipFile = function(src, dest, shellUnzipOnly, cb) {
    console.log("Unzipping " + src);
    return _unzipViaShell(src, dest, function(err) {
      if (err) {
        console.warn("Unzipping", src, "failed, retrying in 50ms");
        return setTimeout(function() {
          return unzipFile(src, dest, shellUnzipOnly, cb);
        }, 50);
      } else {
        return typeof cb === "function" ? cb(err) : void 0;
      }
    });
  };

  chmodRecursiveSync = function(file) {
    var error;
    try {
      fs.chmodSync(file, '777');
    } catch (_error) {
      error = _error;
      console.warn(error);
      return;
    }
    if (fs.statSync(file).isDirectory()) {
      return fs.readdirSync(file).forEach(function(subFile) {
        return chmodRecursiveSync(path.join(file, subFile));
      });
    }
  };

  _extractAppZip = function(src, dest, shellUnzipOnly, cb) {
    var err;
    if (!fs.existsSync(src)) {
      return typeof cb === "function" ? cb(new Error("Zip archive does not exist: " + src)) : void 0;
    }
    try {
      if (fs.existsSync(dest)) {
        fs.removeSync(dest);
      }
      fs.mkdirpSync(dest);
    } catch (_error) {
      err = _error;
      console.warn("Error deleting directory \"" + dest + "\": " + (err.stack || err));
      return typeof cb === "function" ? cb(err) : void 0;
    }
    return unzipFile(src, dest, shellUnzipOnly, function(err) {
      var extractedFiles, failures, moves, possibleAppDirs, topLevelDir;
      console.log("unzipping " + src);
      if (err) {
        return typeof cb === "function" ? cb(err) : void 0;
      }
      if (os.platform() === "win32") {
        try {
          extractedFiles = fs.readdirSync(dest);
          possibleAppDirs = [];
          extractedFiles.forEach(function(extractedFile) {
            if (!IgnoredWindowsFileRegex.test(extractedFile)) {
              return possibleAppDirs.push(extractedFile);
            }
          });
          console.log("found possible app dirs: " + JSON.stringify(possibleAppDirs));
          if (possibleAppDirs.length === 1 && fs.statSync(path.join(dest, possibleAppDirs[0])).isDirectory()) {
            topLevelDir = path.join(dest, possibleAppDirs[0]);
            console.log("Moving " + topLevelDir + " to " + dest);
            chmodRecursiveSync(topLevelDir);
            moves = [];
            fs.readdirSync(topLevelDir).forEach(function(appFile) {
              return moves.push(function(cb) {
                return mv(path.join(topLevelDir, appFile), path.join(dest, appFile), {
                  mkdirp: true
                }, cb);
              });
            });
            failures = 0;
            return async.eachSeries(moves, function(move, cb) {
              return move(function(err) {
                if (!err) {
                  return cb(null);
                }
                if (failures < 3) {
                  moves.push(function(cb) {
                    return setTimeout(function() {
                      return move(cb);
                    }, 1000);
                  });
                  failures++;
                  return cb(null);
                } else {
                  return cb(err);
                }
              });
            }, cb);
          } else {
            return typeof cb === "function" ? cb(null) : void 0;
          }
        } catch (_error) {
          err = _error;
          return typeof cb === "function" ? cb(err) : void 0;
        }
      } else {
        return typeof cb === "function" ? cb(null) : void 0;
      }
    });
  };

  _extractAppDmg = function(src, dest, cb) {
    if (!fs.existsSync(src)) {
      return typeof cb === "function" ? cb(new Error("Disk image does not exist: " + src)) : void 0;
    }
    if (os.platform() !== "darwin") {
      return typeof cb === "function" ? cb(new Error("Extracting DMG is only supported on Mac OS X.")) : void 0;
    }
    return exec("hdiutil mount -nobrowse " + shell.escape(src) + " -plist", function(err, stdout) {
      var appPackage, dirEntries, dirEntry, dirErr, entry, err2, isValidDir, mkdirErr, mountPoint, parsedOutput, readErr, systemEntities, systemEntity, unmount, _i, _j, _len, _len1;
      unmount = function(callback) {
        console.log("Unmounting and ejecting dmg at " + mountPoint);
        return exec("diskutil eject " + shell.escape(mountPoint), callback);
      };
      if (err) {
        return typeof cb === "function" ? cb(err) : void 0;
      }
      mountPoint = void 0;
      try {
        parsedOutput = plist.parseStringSync(stdout.toString());
        systemEntities = parsedOutput["system-entities"];
        for (_i = 0, _len = systemEntities.length; _i < _len; _i++) {
          systemEntity = systemEntities[_i];
          if (systemEntity["mount-point"]) {
            mountPoint = systemEntity["mount-point"];
            break;
          }
        }
      } catch (_error) {
        err2 = _error;
        return typeof cb === "function" ? cb(err2) : void 0;
      }
      if (!mountPoint) {
        return typeof cb === "function" ? cb(new Error("Mounting disk image failed.")) : void 0;
      }
      try {
        dirEntries = fs.readdirSync(mountPoint);
      } catch (_error) {
        readErr = _error;
        console.error("Failed to read mount point");
        return typeof cb === "function" ? cb(readErr) : void 0;
      }
      appPackage = void 0;
      for (_j = 0, _len1 = dirEntries.length; _j < _len1; _j++) {
        entry = dirEntries[_j];
        dirEntry = path.join(mountPoint, entry);
        try {
          isValidDir = /\.app$/i.test(dirEntry) && fs.statSync(dirEntry).isDirectory();
        } catch (_error) {
          dirErr = _error;
          isValidDir = false;
        }
        if (isValidDir) {
          if (appPackage) {
            unmount(function() {
              return typeof cb === "function" ? cb(new Error("Multiple .app directories encountered in DMG: " + appPackage + ", " + dirEntry)) : void 0;
            });
          } else {
            appPackage = dirEntry;
          }
        }
      }
      if (!appPackage) {
        return unmount(function() {
          return cb(new Error("No .app directory found in DMG."));
        });
      } else {
        try {
          if (fs.existsSync(dest)) {
            fs.removeSync(dest);
          }
        } catch (_error) {
          err2 = _error;
          return unmount(function() {
            return typeof cb === "function" ? cb(err2) : void 0;
          });
        }
        try {
          fs.mkdirpSync(path.dirname(dest));
        } catch (_error) {
          mkdirErr = _error;
          return typeof cb === "function" ? cb(mkdirErr) : void 0;
        }
        console.log("Installing app from " + appPackage + " to " + dest);
        return exec("cp -r " + shell.escape(appPackage) + " " + shell.escape(dest), function(err) {
          if (err) {
            return unmount(function(err2) {
              return typeof cb === "function" ? cb(err || err2 || null) : void 0;
            });
          } else {
            return exec("xattr -rd com.apple.quarantine " + shell.escape(dest), function(err3) {
              if (err3) {
                console.warn("xattr exec error, ignoring: " + err3);
              }
              return unmount(cb);
            });
          }
        });
      }
    });
  };

  extractApp = function(src, dest, shellUnzipOnly) {
    if (os.platform() === 'win32') {
      return Q.nfcall(_extractAppZip, src, dest, shellUnzipOnly);
    } else if (os.platform() === 'darwin') {
      return Q.nfcall(_extractAppDmg, src, dest);
    } else {
      return Q.fail(new Error("Don't know how to install apps on platform: " + os.platform()));
    }
  };

  module.exports.unzipFile = unzipFile;

  module.exports.extractApp = extractApp;

  module.exports.chmodRecursiveSync = chmodRecursiveSync;

}).call(this);
